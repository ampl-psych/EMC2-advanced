% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/design.R
\name{make_design}
\alias{make_design}
\title{Specify a design and model}
\usage{
make_design(
  formula = NULL,
  factors = NULL,
  Rlevels = NULL,
  model,
  data = NULL,
  contrasts = NULL,
  matchfun = NULL,
  constants = NULL,
  covariates = NULL,
  functions = NULL,
  report_p_vector = TRUE,
  custom_p_vector = NULL,
  ordinal = NULL,
  dynamic = NULL,
  adaptive = NULL,
  omit_transform = NULL,
  advantage = NULL,
  ...
)
}
\arguments{
\item{formula}{A list. Contains the design formulae in the
format \code{list(y ~ x, a ~ z)}.}

\item{factors}{A named list containing all the factor variables that span
the design cells and that should be taken into account by the model.
The name \code{subjects} must be used to indicate the participant factor variable,
also in the data.

Example: \code{list(subjects=levels(dat$subjects), condition=levels(dat$condition))}}

\item{Rlevels}{A character vector. Contains the response factor levels.
Example: \code{c("right", "left")}}

\item{model}{A function, specifies the model type.
Choose from the drift diffusion model (\code{DDM()}, \code{DDMt0natural()}),
the log-normal race model (\code{LNR()}), the linear ballistic model (\code{LBA()}),
the racing diffusion model (\code{RDM()}, \code{RDMt0natural()}), or define your own
model functions.}

\item{data}{A data frame. \code{data} can be used to automatically detect
\code{factors}, \code{Rlevels} and \code{covariates} in a dataset. The variable \code{R} needs
to be a factor variable indicating the response variable. Any numeric column
except \code{trials} and \code{rt} are treated as covariates, and all remaining factor
variables are internally used in \code{factors}.}

\item{contrasts}{Optional. A named list specifying a design matrix.
Example for supplying a customized design matrix:
\verb{list(lM = matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))))}}

\item{matchfun}{A function. Only needed for race models. Specifies whether a
response was correct or not. Example: \code{function(d)d$S==d$lR} where lR refers
to the latent response factor.}

\item{constants}{A named vector that sets constants. Any parameter in
\code{sampled_p_vector} can be set constant.}

\item{covariates}{Names of numeric covariates.}

\item{functions}{List of functions to create new factors based on those in
the factors argument. These new factors can then be used in \code{formula}.}

\item{report_p_vector}{Boolean. If TRUE (default), it returns the vector of
parameters to be estimated.}

\item{custom_p_vector}{A character vector. If specified, a custom likelihood
function can be supplied.}

\item{ordinal}{For future compatibility}

\item{dynamic}{List with names of dynamic parameters and associated attributes
specifying a dynamic transformation for that parameter in the form of a list
with entries:
\enumerate{
\item covnames: a vector of names (c1, c2, ...) of covariates in the dadm to be
used in the dynamic transformation
\item dyntype: string specifying kernel (k), with parameter (if any) 3x where x
x is the kernel name. Kernels are multiplied by parameter 2x and added to
the base parameter. Supported kernels are:
decreasing linear, "ld"      ( k <- -c1 );
decreasing exponential, "ed" ( k <- exp(-3ed * c1) )
decreasing power, "pd"       ( k <- (1+c1)^-3pd )
increasing linear, "li"      ( k <- c1)
increasing exponential "ei"  ( k <- 1-exp(-3ei * c1) )
increasing power "pi"        ( k <- 1-(1+c1)^-3pi )
OR quadratic to quadratic polynomials that are added to the base parameter,
with parameters 1x, 2x, 3x, 4x, where p2: 1p2 x c1 + 2p2 x c1^2;
p3: 1p3 x c1 + 2p3 x c1^2 + 3p3 x c1^3; and p4: 1p4 x c1 + 2p4 x c1^2 +
3p4 x c1^3 + 4p4 x c1^4
OR learning rules, d1 (standard delta rule) and d2 (dual kernel delta rule)
each coming in three flavors d1U/d2U: learning target is on 0-1 (starting
value estimated on probit scale); d1P/d2P: learning target positive
(starting value estimated on log scale); d1/d2: unbounded learning target.
\item maptype: optional string specifying the linear mapping of kernel or
polynomial (k) to parameter (p), with scale parameter 1p, with types
linear, "lin":              ( p <- p + 1p*k )
positive linear "plin":     ( p <- exp(p) + exp(1p)*k )
additive "add":             ( p <- p + k, used for polynomial which uses 1p)
unit centered "ucent:       ( p <- p + 1p x (k-.5) )
lin is default if not specified
\item transform: optional logical, default TRUE, apply transformation to parameter type
(i.e., to sampled parameters combined by the linear formula)
\item equal_accumulators: boolean, apply dynamic equally to all accumulators.
default is TRUE.
\item dnames: optional vector of names of the dntype parameters that are pasted
to the base type to get sampled parameters (if not specified the 1x ...
form above is used)
\item shared: logical default FALSE. If TRUE the base parameter name is not
pasted so the parameter can be shared across dynamic parameters. If length=1
sharing applied to all parameters, otherwise have length = number of dynamic
parameters.
}}

\item{adaptive}{List with names of parameter types (i.e., after mapping) to
make adaptive. Structure of list as for dynamic except dnames is anames and
transform and equal_accumulators defaults are FALSE}

\item{omit_transform}{Names of parameter types to NOT transform as specified in the model}

\item{advantage}{vector with parameter type name with the name of the function
that generates stimulus values}

\item{...}{Additional optionial arguments}
}
\value{
A design list.
}
\description{
This function combines information regarding the data, type of model, and
the model specification.
}
\examples{

# load example dataset
dat <- forstmann

# create a function that takes the latent response (lR) factor (d) and returns a logical
# defining the correct response for each stimulus. Here the match is simply
# such that the S factor equals the latent response factor
matchfun <- function(d)d$S==d$lR

# When working with lM and lR, it can be useful to design  an
# "average and difference" contrast matrix. For binary responses, it has a
# simple canonical form
ADmat <- matrix(c(-1/2,1/2),ncol=1,dimnames=list(NULL,"diff"))

# Create a design for a linear ballistic accumulator model (LBA) that allows
# thresholds to be a function of E and lR. The final result is a 9 parameter model.
design_LBABE <- make_design(data = dat,model=LBA,matchfun=matchfun,
                            formula=list(v~lM,sv~lM,B~E+lR,A~1,t0~1),
                            contrasts=list(v=list(lM=ADmat)),
                            constants=c(sv=log(1)))
}
